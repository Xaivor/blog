import{_ as e,c as o,o as a,a2 as c}from"./chunks/framework.DwDoyBw8.js";const b=JSON.parse('{"title":"React 部分","description":"","frontmatter":{},"headers":[],"relativePath":"knowledge/react.md","filePath":"knowledge/react.md"}'),t={name:"knowledge/react.md"},d=c('<h1 id="react-部分" tabindex="-1">React 部分 <a class="header-anchor" href="#react-部分" aria-label="Permalink to &quot;React 部分&quot;">​</a></h1><p>下面是常见的 <code>React</code> 基础问题：</p><h2 id="_1-react-中的-fiber-架构-⭐" tabindex="-1">1. React 中的 Fiber 架构 ⭐ <a class="header-anchor" href="#_1-react-中的-fiber-架构-⭐" aria-label="Permalink to &quot;1. React 中的 Fiber 架构 ⭐&quot;">​</a></h2><p><code>Fiber</code> 架构是 <code>React</code> 16 引入的一种新的架构，它允许 <code>React</code> 在渲染过程中进行中断和恢复，从而实现更流畅的用户体验。</p><p>解决的痛点：</p><ul><li><code>增量渲染</code>：Fiber 架构可以将渲染工作拆分成多个时间片段执行，使得每个时间片段都有机会插入其他优先级更高的任务，从而在保证页面响应性的同时，尽可能快地完成渲染工作。</li><li><code>优先级调度</code>：Fiber 架构引入了任务优先级的概念，可以根据任务的紧急程度和重要性对任务进行优先级排序，确保优先级较高的任务能够尽早得到处理，提高用户交互的流畅度。</li><li><code>可中断和恢复</code>：Fiber 架构支持任务的中断和恢复，即在渲染过程中，如果有更高优先级的任务需要处理，当前任务可以被暂停并稍后恢复，以确保更及时地响应用户操作。</li><li><code>更好的错误处理</code>：Fiber 架构为错误处理提供了更好的机制。每个 Fiber 都有自己的错误边界，可以捕获并处理组件树中发生的错误，并在不崩溃整个应用程序的情况下进行优雅降级。</li></ul><h2 id="_2-react-中的-diff-算法-⭐" tabindex="-1">2. React 中的 Diff 算法 ⭐ <a class="header-anchor" href="#_2-react-中的-diff-算法-⭐" aria-label="Permalink to &quot;2. React 中的 Diff 算法 ⭐&quot;">​</a></h2><p><code>React Diff</code> 算法是 React 虚拟 Dom 的核心。它允许 React 快速确定虚拟 Dom 树上的哪些部分需要更新，从而使得 UI 更新非常的高效。</p><h3 id="同级比较" tabindex="-1">同级比较 <a class="header-anchor" href="#同级比较" aria-label="Permalink to &quot;同级比较&quot;">​</a></h3><ul><li>React 不会进行跨层级的 DOM 比较。它只比较同一层级的元素。</li></ul><h3 id="元素类型" tabindex="-1">元素类型 <a class="header-anchor" href="#元素类型" aria-label="Permalink to &quot;元素类型&quot;">​</a></h3><ul><li><strong>类型不同，删除重建</strong>：当两棵树的相同位置找到两个不同类型的元素时，React 会直接销毁旧节点及其子节点，并从头开始创建新节点。</li><li><strong>类型相同，复用节点</strong>：如果两个元素是相同类型的，React 会保留该 DOM 节点，并仅更新变化的属性。并递归地对其子节点进行比较。</li></ul><h3 id="keys重要性" tabindex="-1">Keys重要性 <a class="header-anchor" href="#keys重要性" aria-label="Permalink to &quot;Keys重要性&quot;">​</a></h3><p>当在数组中渲染子节点时，必须为每个子节点分配一个稳定的 Key 值。通过为每个节点分配一个 Key，React 可以使用这个 Key 来识别那些在不同的渲染中仍然保持不变的元素。</p><blockquote><p>如果你没有设置 Key，React 内部会默认使用元素的索引作为它们的 Key</p><p><code>若是设置一个随机 Key 会怎样</code>？</p></blockquote><p><strong>现象</strong>：每次组件渲染，随机 Key 值都会变化，即时实际渲染的数据没有变，这个元素也会被销毁重新创建。</p><p>这将导致以下问题出现：</p><ol><li>性能下降</li><li>状态丢失 <ul><li>如果一个组件或元素依赖于本地状态或维护状态（如输入字段）。</li></ul></li><li>不一致的 DOM 行为 <ul><li>这可能导致不可预测的行为，如焦点丢失、文本选择丢失等。</li></ul></li></ol><h2 id="_3-react-中的-virtual-dom-⭐" tabindex="-1">3. React 中的 Virtual DOM ⭐ <a class="header-anchor" href="#_3-react-中的-virtual-dom-⭐" aria-label="Permalink to &quot;3. React 中的 Virtual DOM ⭐&quot;">​</a></h2><p>虚拟 DOM 本质上是一个 JS 对象，它反映了真实 DOM 的结构和内容。</p><ul><li>1.提供一个中间缓存，使得直接操作实际的 DOM（这通常是昂贵的操作）不再那么频繁。</li><li>2.通过对比新旧虚拟 DOM 来计算出最小的变动，从而优化实际 DOM 的更新。</li></ul><p>虚拟 DOM 可以让 React 更优雅高效的更新真实 DOM，虚拟 DOM 可以让开发者不用关注 DOM 操作，只操作数据。</p><h2 id="_4-react-中的-hooks-⭐" tabindex="-1">4. React 中的 Hooks ⭐ <a class="header-anchor" href="#_4-react-中的-hooks-⭐" aria-label="Permalink to &quot;4. React 中的 Hooks ⭐&quot;">​</a></h2><p><code>Hooks</code> 是 React 16.8 版本引入的新特性，它允许在函数组件中使用状态（state）和生命周期（lifecycle）等 React 特性。</p><h3 id="常用-hooks" tabindex="-1">常用 Hooks <a class="header-anchor" href="#常用-hooks" aria-label="Permalink to &quot;常用 Hooks&quot;">​</a></h3><ul><li><code>useState</code>：用于在函数组件中定义和更新状态（state）。</li><li><code>useEffect</code>：用于在函数组件中执行副作用操作（side effect）。</li><li><code>useContext</code>：用于在函数组件中获取上下文（context）的值。</li><li><code>useReducer</code>：用于在函数组件中实现状态管理。</li><li><code>useRef</code>：用于在函数组件中获取对 DOM 元素的引用。</li><li><code>useCallback</code>：用于在函数组件中缓存函数。</li><li><code>useMemo</code>：用于在函数组件中缓存计算结果。</li><li><code>useLayoutEffect</code>：类似于 <code>useEffect</code>，但会在 DOM 更新后同步调用副作用函数。</li></ul><h2 id="_5-react-中的生命周期-⭐" tabindex="-1">5. React 中的生命周期 ⭐ <a class="header-anchor" href="#_5-react-中的生命周期-⭐" aria-label="Permalink to &quot;5. React 中的生命周期 ⭐&quot;">​</a></h2><p>React 组件的生命周期是指组件从创建到销毁的过程，它包括三个阶段：<code>挂载</code>、<code>更新</code>和<code>卸载</code>。</p><ul><li><code>挂载</code>：组件创建时，会调用 <code>constructor</code> 方法，然后调用 <code>render</code> 方法，最后调用 <code>componentDidMount</code> 方法。</li><li><code>更新</code>：当组件的 <code>props</code> 或 <code>state</code> 发生变化时，会调用 <code>render</code> 方法，然后调用 <code>componentDidUpdate</code> 方法。</li><li><code>卸载</code>：当组件从 DOM 中移除时，会调用 <code>componentWillUnmount</code> 方法。</li></ul><h3 id="挂载阶段" tabindex="-1">挂载阶段 <a class="header-anchor" href="#挂载阶段" aria-label="Permalink to &quot;挂载阶段&quot;">​</a></h3><ul><li><code>constructor</code>：在组件创建时调用，用于初始化组件的状态。</li><li><code>render</code>：在组件创建时调用，用于返回组件的 UI 结构。</li><li><code>componentDidMount</code>：在组件挂载后调用，用于执行一些副作用操作，如发送网络请求、订阅事件等。</li></ul><h3 id="更新阶段" tabindex="-1">更新阶段 <a class="header-anchor" href="#更新阶段" aria-label="Permalink to &quot;更新阶段&quot;">​</a></h3><ul><li><code>componentWillReceiveProps</code>：在组件接收到新的 <code>props</code> 时调用，用于更新组件的状态。</li><li><code>shouldComponentUpdate</code>：在组件接收到新的 <code>props</code> 或 <code>state</code> 时调用，用于判断是否需要重新渲染组件。</li><li><code>componentWillUpdate</code>：在组件接收到新的 <code>props</code> 或 <code>state</code> 且 <code>shouldComponentUpdate</code> 返回 <code>true</code> 时调用，用于更新组件的状态。</li><li><code>render</code>：在组件接收到新的 <code>props</code> 或 <code>state</code> 时调用，用于返回组件的 UI 结构。</li><li><code>componentDidUpdate</code>：在组件更新后调用，用于执行一些副作用操作，如发送网络请求、订阅事件等。</li></ul><h3 id="卸载阶段" tabindex="-1">卸载阶段 <a class="header-anchor" href="#卸载阶段" aria-label="Permalink to &quot;卸载阶段&quot;">​</a></h3><ul><li><code>componentWillUnmount</code>：在组件从 DOM 中移除时调用，用于执行一些清理操作，如取消订阅事件、清除定时器等。</li></ul>',35),l=[d];function i(r,n,s,u,h,p){return a(),o("div",null,l)}const m=e(t,[["render",i]]);export{b as __pageData,m as default};
